{
  "version": 3,
  "sources": ["../../../../../node_modules/@angular/fire/fesm2022/angular-fire-performance.mjs", "../../../../../node_modules/rxfire/performance/index.esm.js"],
  "sourcesContent": ["import { ɵgetAllInstancesOf as _getAllInstancesOf, ɵgetDefaultInstanceOf as _getDefaultInstanceOf, VERSION, ɵAngularFireSchedulers as _AngularFireSchedulers, ɵzoneWrap as _zoneWrap } from '@angular/fire';\nimport { timer, from } from 'rxjs';\nimport { concatMap, distinct } from 'rxjs/operators';\nimport { isPlatformBrowser } from '@angular/common';\nimport * as i0 from '@angular/core';\nimport { InjectionToken, Optional, PLATFORM_ID, NgModule, makeEnvironmentProviders, NgZone, Injector } from '@angular/core';\nimport { FirebaseApp, FirebaseApps } from '@angular/fire/app';\nimport { registerVersion } from 'firebase/app';\nimport { traceUntil as traceUntil$1, traceWhile as traceWhile$1, traceUntilComplete as traceUntilComplete$1, traceUntilFirst as traceUntilFirst$1 } from 'rxfire/performance';\nimport { getPerformance as getPerformance$1, initializePerformance as initializePerformance$1, trace as trace$1 } from 'firebase/performance';\nexport * from 'firebase/performance';\nclass Performance {\n  constructor(performance) {\n    return performance;\n  }\n}\nconst PERFORMANCE_PROVIDER_NAME = 'performance';\nclass PerformanceInstances {\n  constructor() {\n    return _getAllInstancesOf(PERFORMANCE_PROVIDER_NAME);\n  }\n}\nconst performanceInstance$ = timer(0, 300).pipe(concatMap(() => from(_getAllInstancesOf(PERFORMANCE_PROVIDER_NAME))), distinct());\nconst PROVIDED_PERFORMANCE_INSTANCES = new InjectionToken('angularfire2.performance-instances');\nfunction defaultPerformanceInstanceFactory(provided, defaultApp,\n// eslint-disable-next-line @typescript-eslint/ban-types\nplatform) {\n  if (!isPlatformBrowser(platform)) {\n    return null;\n  }\n  const defaultPerformance = _getDefaultInstanceOf(PERFORMANCE_PROVIDER_NAME, provided, defaultApp);\n  return defaultPerformance && new Performance(defaultPerformance);\n}\nfunction performanceInstanceFactory(fn) {\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  return (zone, platform, injector) => {\n    if (!isPlatformBrowser(platform)) {\n      return null;\n    }\n    const performance = zone.runOutsideAngular(() => fn(injector));\n    return new Performance(performance);\n  };\n}\nconst PERFORMANCE_INSTANCES_PROVIDER = {\n  provide: PerformanceInstances,\n  deps: [[new Optional(), PROVIDED_PERFORMANCE_INSTANCES]]\n};\nconst DEFAULT_PERFORMANCE_INSTANCE_PROVIDER = {\n  provide: Performance,\n  useFactory: defaultPerformanceInstanceFactory,\n  deps: [[new Optional(), PROVIDED_PERFORMANCE_INSTANCES], FirebaseApp, PLATFORM_ID]\n};\nclass PerformanceModule {\n  constructor() {\n    registerVersion('angularfire', VERSION.full, 'perf');\n  }\n  static ɵfac = function PerformanceModule_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || PerformanceModule)();\n  };\n  static ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: PerformanceModule\n  });\n  static ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [DEFAULT_PERFORMANCE_INSTANCE_PROVIDER, PERFORMANCE_INSTANCES_PROVIDER]\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(PerformanceModule, [{\n    type: NgModule,\n    args: [{\n      providers: [DEFAULT_PERFORMANCE_INSTANCE_PROVIDER, PERFORMANCE_INSTANCES_PROVIDER]\n    }]\n  }], () => [], null);\n})();\nfunction providePerformance(fn, ...deps) {\n  registerVersion('angularfire', VERSION.full, 'perf');\n  return makeEnvironmentProviders([DEFAULT_PERFORMANCE_INSTANCE_PROVIDER, PERFORMANCE_INSTANCES_PROVIDER, {\n    provide: PROVIDED_PERFORMANCE_INSTANCES,\n    useFactory: performanceInstanceFactory(fn),\n    multi: true,\n    deps: [NgZone, PLATFORM_ID, Injector, _AngularFireSchedulers, FirebaseApps, ...deps]\n  }]);\n}\n\n// DO NOT MODIFY, this file is autogenerated by tools/build.ts\nconst traceUntil = _zoneWrap(traceUntil$1, true);\nconst traceWhile = _zoneWrap(traceWhile$1, true);\nconst traceUntilComplete = _zoneWrap(traceUntilComplete$1, true);\nconst traceUntilFirst = _zoneWrap(traceUntilFirst$1, true);\n\n// DO NOT MODIFY, this file is autogenerated by tools/build.ts\nconst getPerformance = _zoneWrap(getPerformance$1, true);\nconst initializePerformance = _zoneWrap(initializePerformance$1, true);\nconst trace = _zoneWrap(trace$1, true);\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { Performance, PerformanceInstances, PerformanceModule, getPerformance, initializePerformance, performanceInstance$, providePerformance, trace, traceUntil, traceUntilComplete, traceUntilFirst, traceWhile };\n", "import { from, Observable, EMPTY } from 'rxjs';\nimport { tap } from 'rxjs/operators';\n\n/**\n * Lazy loads Firebase Performance monitoring and returns the instance as\n * an observable\n * @param app\n * @returns Observable<FirebasePerformance>\n */\nvar getPerformance$ = function (app) {\n  return from(import('firebase/performance').then(function (module) {\n    return module.getPerformance(app);\n  }));\n};\n/**\n * Creates an observable that begins a trace with a given id. The trace is ended\n * when the observable unsubscribes. The measurement is also logged as a performance\n * entry.\n * @param traceId\n * @returns Observable<void>\n */\nvar trace$ = function (traceId) {\n  if (typeof window !== 'undefined' && window.performance) {\n    var entries = window.performance.getEntriesByName(traceId, 'measure') || [];\n    var startMarkName_1 = \"_\".concat(traceId, \"Start[\").concat(entries.length, \"]\");\n    var endMarkName_1 = \"_\".concat(traceId, \"End[\").concat(entries.length, \"]\");\n    return new Observable(function (emitter) {\n      window.performance.mark(startMarkName_1);\n      emitter.next();\n      return {\n        unsubscribe: function () {\n          window.performance.mark(endMarkName_1);\n          window.performance.measure(traceId, startMarkName_1, endMarkName_1);\n        }\n      };\n    });\n  } else {\n    return EMPTY;\n  }\n};\n/**\n * Creates a function that creates an observable that begins a trace with a given id. The trace is ended\n * when the observable unsubscribes. The measurement is also logged as a performance\n * entry.\n * @param name\n * @returns (source$: Observable<T>) => Observable<T>\n */\nvar trace = function (name) {\n  return function (source$) {\n    return new Observable(function (subscriber) {\n      var traceSubscription = trace$(name).subscribe();\n      return source$.pipe(tap(function () {\n        return traceSubscription.unsubscribe();\n      }, function () {}, function () {\n        return traceSubscription.unsubscribe();\n      })).subscribe(subscriber);\n    });\n  };\n};\n/**\n * Creates a function that creates an observable that begins a trace with a given name. The trace runs until\n * a condition resolves to true and then the observable unsubscribes and ends the trace.\n * @param name\n * @param test\n * @param options\n * @returns (source$: Observable<T>) => Observable<T>\n */\nvar traceUntil = function (name, test, options) {\n  return function (source$) {\n    return new Observable(function (subscriber) {\n      var traceSubscription = trace$(name).subscribe();\n      return source$.pipe(tap(function (a) {\n        return test(a) && traceSubscription.unsubscribe();\n      }, function () {}, function () {\n        return options && options.orComplete && traceSubscription.unsubscribe();\n      })).subscribe(subscriber);\n    });\n  };\n};\n/**\n * Creates a function that creates an observable that begins a trace with a given name. The trace runs while\n * a condition resolves to true. Once the condition fails the observable unsubscribes\n * and ends the trace.\n * @param name\n * @param test\n * @param options\n * @returns (source$: Observable<T>) => Observable<T>\n */\nvar traceWhile = function (name, test, options) {\n  return function (source$) {\n    return new Observable(function (subscriber) {\n      var traceSubscription;\n      return source$.pipe(tap(function (a) {\n        if (test(a)) {\n          traceSubscription = traceSubscription || trace$(name).subscribe();\n        } else {\n          if (traceSubscription) {\n            traceSubscription.unsubscribe();\n          }\n          traceSubscription = undefined;\n        }\n      }, function () {}, function () {\n        return options && options.orComplete && traceSubscription && traceSubscription.unsubscribe();\n      })).subscribe(subscriber);\n    });\n  };\n};\n/**\n * Creates a function that creates an observable that begins a trace with a given name. The trace runs until the\n * observable fully completes.\n * @param name\n * @returns (source$: Observable<T>) => Observable<T>\n */\nvar traceUntilComplete = function (name) {\n  return function (source$) {\n    return new Observable(function (subscriber) {\n      var traceSubscription = trace$(name).subscribe();\n      return source$.pipe(tap(function () {}, function () {}, function () {\n        return traceSubscription.unsubscribe();\n      })).subscribe(subscriber);\n    });\n  };\n};\n/**\n * Creates a function that creates an observable that begins a trace with a given name.\n * The trace runs until the first value emits from the provided observable.\n * @param name\n * @returns (source$: Observable<T>) => Observable<T>\n */\nvar traceUntilFirst = function (name) {\n  return function (source$) {\n    return new Observable(function (subscriber) {\n      var traceSubscription = trace$(name).subscribe();\n      return source$.pipe(tap(function () {\n        return traceSubscription.unsubscribe();\n      }, function () {}, function () {})).subscribe(subscriber);\n    });\n  };\n};\nexport { getPerformance$, trace, traceUntil, traceUntilComplete, traceUntilFirst, traceWhile };\n"],
  "mappings": "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",
  "names": ["import_rxjs", "import_operators", "traceUntil", "traceWhile", "traceUntilComplete", "traceUntilFirst", "getPerformance", "initializePerformance", "trace"]
}
